use std::{
    collections::HashMap,
    sync::Arc,
    path::PathBuf,
    env,
};

use tokio::{
    sync::{Mutex, mpsc::UnboundedSender},
};

use axum::{
    extract::ws::Message,
};

use sqlx::{
    mysql::MySqlPool,
};

use argon2::{
    {Argon2, PasswordHasher, PasswordHash, PasswordVerifier},
    password_hash::SaltString,
};

use rand::{
    rngs::OsRng,
};

use dotenvy::from_path;

use error::{
    AuthenticateErrorType,
};

#[derive(Eq, Hash, PartialEq, Clone)]
pub struct User {
    pub username: String,
}

impl User {
    pub fn new(username: &str) -> Self {
        Self {
            username: String::from(username),
        }
    }
}

#[derive(Clone)]
pub struct Users {
    pub on_users: Arc<Mutex<HashMap<User, UnboundedSender<Message>>>>,
}

impl Users {
    pub fn new() -> Self {
        Self {
            on_users: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    async fn connect_to_database() -> Result<MySqlPool, AuthenticateErrorType> {
        let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        path.pop();
        path.push(".env");

        from_path(path.as_path()).unwrap();

        let db_url = env::var("DATABASE_URL").expect("DATABASE_URL nÃ£o definida");
        let pool = MySqlPool::connect(&db_url).await?;

        Ok(pool)    
    }

    pub async get_o

    pub async fn add_user
    (
        username: &str,
        password: &str,
    ) -> Result<(), AuthenticateErrorType>
    {
        let pool = Self::connect_to_database().await?;
        let password_hash = Self::hash_password(password)?;

        match sqlx::query!(
            "INSERT INTO users (username, password_hash) VALUES (?, ?)",
            username,
            password_hash,
        )
        .fetch_optional(&pool)
        .await {
            Ok(_) => {},
            Err(_) => return Err(AuthenticateErrorType::UserAlreadyExists),
        };

        Ok(())
    }

    pub async fn remove_user
    (
        &mut self,
        username: &str,
    ) -> Option<UnboundedSender<Message>>
    {
        let mut on_users = self.on_users.lock().await;
        on_users.remove(&User::new(username))        
    }

    fn hash_password
    (
        password: &str,
    ) -> Result<String, argon2::password_hash::Error>
    {
        let salt = SaltString::generate(&mut OsRng);
        let argon2 = Argon2::default();

        let password_hash = argon2.hash_password(password.as_bytes(), &salt)?;
        Ok(password_hash.to_string())
    }

    fn check_password
    (
        hash_found: &str,
        password_given: &str,
    ) -> Result<bool, argon2::password_hash::Error>
    {
        let parsed_hash = PasswordHash::new(hash_found)?;
        Ok(Argon2::default().verify_password(password_given.as_bytes(),
            &parsed_hash)
            .is_ok()
        )
    }

    pub async fn authenticate_user
    (
        &mut self,
        username: &str,
        password: &str,
        sender: UnboundedSender<Message>
    ) -> Result<(), AuthenticateErrorType>
    {
        let pool = Self::connect_to_database().await?;

        if let Some(row) = sqlx::query!(
            "SELECT id, username, password_hash FROM users WHERE username = ?",
            username,
        )
        .fetch_optional(&pool)
        .await? {
            let hash_found = row.password_hash;
            let valid_user = Self::check_password(&hash_found, password)?;

            match valid_user {
                true => {
                    let mut on_users = self.on_users.lock().await;
                    on_users.insert(User::new(username), sender);
                    Ok(())
                },
                false => Err(AuthenticateErrorType::PasswordMismatch),
            }        
        } else {
            Err(AuthenticateErrorType::UserNotFound)
        }
    }
}