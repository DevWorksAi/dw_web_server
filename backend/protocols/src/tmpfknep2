use serde::{
    Deserialize,
    Serialize,
};

use error::{
	ProtocolError,
};

use futures_util::sink::SinkExt;
use axum::extract::ws::Message;
use std::future::Future;
use types::ArcWriter;

pub trait Protocol: Sized + Serialize + for<'de> Deserialize<'de> {
    fn serialize_and<R, F, Fut>(self, f: F) -> 
        impl Future<Output = Result<R, ProtocolError>> + Send
    where
        Self: Serialize + Send + Sized + 'static,
        F: FnOnce(String) -> Fut + Send,
        Fut: Future<Output = R> + Send,
        R: Send,
    {
        async move {
            let string = serde_json::to_string(&self)?;
            let result = f(string).await;
            Ok(result)
        }
    }

    fn deserialize_and<R, F, Fut>(s: &str, f: F) -> 
        impl Future<Output = Result<R, ProtocolError>> + Send
    where
        F: FnOnce(Self) -> Fut + Send,
        Fut: Future<Output = R> + Send,
        R: Send,
    {   
        async move {
            let val = serde_json::from_str(s)?;
            let result = f(val).await;
            Ok(result)
        }
    }
}

#[derive(Debug, Deserialize, Serialize)]
#[serde(tag = "type")]
pub enum ClientProtocol {
    #[serde(rename = "send_message")]
    SendMessage { from: String, to: String, text: String },

    #[serde(rename = "request_authenticate")]
    RequestAuthenticate { username: String, password: String },

    #[serde(rename = "create_user")]
    CreateUser { username: String, password: String },

    /* 
    Protocols a implementar:
    RequestFeed,
    */
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ServerProtocol {
    #[serde(rename = "message")]
    Message { from: String, to: String, text: String },

    #[serde(rename = "message_sent")]
    MessageSent,

    #[serde(rename = "user_disconnected")]
    UserDisconnected { username: String },

    #[serde(rename = "error")]
    Error { error: ProtocolError },

    #[serde(rename = "authenticated")]
    Authenticated,

    #[serde(rename = "user_created")]
    UserCreated,

    #[serde(r)]

    /* 
    Protocols a implementar:
    Feed,
    */
}

impl Protocol for ClientProtocol {}
impl Protocol for ServerProtocol {}

impl ServerProtocol {
    pub async fn handle_result
    (
        r: Result<Self, ProtocolError>,
        writer: ArcWriter,
    )
    {
        match r {
            Ok(protocol) => {
                let _ = protocol.serialize_and(async |json| {
                    let mut writer = writer.lock().await;
                    writer.send(Message::Text(json.into())).await;
                });
            },
            Err(e) => {
                let err = ServerProtocol::Error {
                    error: e,
                };

                let _ = err.serialize_and(async |json| {
                    let mut writer = writer.lock().await;
                    if writer.send(Message::Text(json.into())).await.is_err() {
                        writer.close().await;
                        eprintln!(
                            "Conex√£o fechada com {addr:?}; motivo: erro ao tentar enviar pela socket")
                    }
                });
            }
        }
    }
}