use std::{
    net::SocketAddr,
    sync::Arc,
};

use tokio::
    sync::{
        mpsc::unbounded_channel, 
        Mutex,
    };

use axum::{
    extract::{
        ws::{WebSocketUpgrade, WebSocket, Message},
        ConnectInfo,
        State,
    },
    response::Response,
};

use futures_util::{
    sink::SinkExt,
    stream::StreamExt,
};

use protocols::{
    ClientProtocol, 
    Protocol,
};

use users::{
    Users,
    User,
};

use crate::handle::handle_protocols::handle_protocol;
use types::{Tx, Rx, ArcReader,
                           ArcWriter, ArcUser, ArcUsers};

// Responsável por lidar com o Https recebido do client
pub async fn handler
(
    ws: WebSocketUpgrade,
    State(users): State<Users>,
    ConnectInfo(addr): ConnectInfo<SocketAddr>,
) -> Response 
{
    // Se o HTTPS vier com a tag UPGRADE, aprimora
    // o WebSocketUpgrade em um WebSocket
    ws.on_upgrade(move |socket| handle_socket(socket, users, addr))
}

// Função principal para leitura e envio de 
// dados pela socket e channel. tratamento desses
// dados.
pub async fn handle_socket
(
    socket: WebSocket,
    users: Users,
    addr: SocketAddr
)
{
    println!("client conectado: {addr}");
    // Cria a socket e o channel.
    let (tx, rx): (Tx, Rx) = unbounded_channel();
    let (write, read) = socket.split();

    let reader = Arc::new(Mutex::new(read));
    let writer = Arc::new(Mutex::new(write));
    let user = Arc::new(Mutex::new(User::new("")));
    let users = Arc::new(Mutex::new(users));

    // task responsável por enviar ao broadcast
    let tx_task = tokio::spawn(receive_from_socket(
        Arc::clone(&reader),
        Arc::clone(&writer),
        Arc::clone(&user),
        Arc::clone(&users),
        tx.clone(),
        addr,
    ));

    // task responsável por ler do broadcast
    let rx_task = tokio::spawn(send_to_socket(
        Arc::clone(&writer),
        rx,
    ));

    // espera até uma das duas tasks terminar primeiro
    tokio::select! {
        _ = tx_task => {}
        _ = rx_task => {}
    }
}

async fn receive_from_socket
(
    reader: ArcReader,
    writer: ArcWriter,
    user: ArcUser,
    users: ArcUsers,
    tx: Tx,
    addr: SocketAddr,
)
{  
    let mut reader = reader.lock().await;

    while let Some(Ok(msg)) = reader.next().await {
        if let Message::Text(text) = msg {
            let _ = ClientProtocol
            ::deserialize_and(&text, async |protocol| {
                handle_protocol(
                        protocol, 
                        user.clone(),
                        users.clone(),
                        tx.clone(),
                        writer.clone(),
                        addr,
                ).await;             
            }).await;
        }
    }
}

async fn send_to_socket
(
    writer: ArcWriter,
    mut rx: Rx,
)
{
    while let Some(msg) = rx.recv().await {
        let mut writer = writer.lock().await;
        if writer.send(msg).await.is_err() {
            break;
        }
    }
}